import sys, os
import json
import numpy as np
from scipy.optimize import curve_fit
import warnings

warnings.filterwarnings("ignore")

# Add src directory to system path
project_path = os.getcwd().split("/src")[0]
sys.path.append(project_path)

try:
    from src.models.event import Event
    from src.utils.functions import gaussian
    from src.utils.functions import hist_to_scatter
except ImportError as e:
    print("Failed to import local modules:")
    print(e)

# Define important paths
lcd_path  = os.path.join(project_path, "lcd")
out_path  = os.path.join(project_path, "out")
plt_path  = os.path.join(project_path, "plt")


# extract calibration.json popt
json_path = os.path.join(out_path, "calibration.json")
with open(json_path, "r") as f:
    content = json.load(f)
    linear_popt = content["popt"]


class Run:

    def __init__(self):
        self.data  = []
        self.rates = []
        self.total_time = 0
        self.event_num = 0


    def check_segment_number(self, runpath):

        seg = 1
        for file in os.listdir(runpath):
            #print(f"Current seg: {seg}")
            try:
                segment_number = int(file.split("seg")[1].split("-")[0])
                if segment_number > seg:
                    seg = segment_number
            except:
                pass

        return segment_number


    def get_timestamps(self, filepath, segments):
        """
        Reads the <filename>_info.txt files generated by IF_bin_to_csv.py script
        and extracts an array of timestamps.

        Args:
            filepath (str) : path to <filename>_info.txt file
                             example filename: 'scope-1-run7_info.txt'
            segments (int) : the total number of segments in a run (1000 is max for
                             our scope)
        Returns:
            timestamps (ndarray) : numpy array of floats in seconds
        """
        try:
            with open(filepath, 'r') as f:
                lines = f.readlines()

            # Initialise empty timestamps numpy array, expect floats
            timestamps = np.empty(segments, dtype=float)
            count      = 0

            # Loop through all the lines in the file to find 'Time Tags'
            for line in lines:
                if count >= segments:
                    break
                if 'Time Tags' in line:
                    timestamp = line.split(" = ")[-1]
                    timestamp = float(timestamp.split('\'')[1])
                    timestamps[count] = timestamp
                    count += 1

            # Cut the timestamps array if there are less events than
            # expected segments
            if count < segments:
                timestamps = timestamps[:count]

            return timestamps

        except Exception as e:
            print("Error in 'get_timestamps'")
            print(e)
            return None


    def event_processor(self, event, linear_popt = linear_popt, PEAK_THRESH=125, INGRESS_THRESH=25, T_MIN=-50, T_MAX=75, L=43):

        # timestamp
        event.read_timestamp()
        timestamp = event.get_timestamp()

        # set peak and ingress thresholds
        event.set_peak_threshold(PEAK_THRESH)
        event.set_ingress_threshold(INGRESS_THRESH)

        # gather waveforms of event
        event.gather_waveforms()

        # set Region Of Interest (ROI)
        event.set_ROI((T_MIN, T_MAX))

        # set track parameters
        positions=np.array([L*0, L*1, L*2, L*3])
        event.set_track_params(positions=positions, linear_popt=linear_popt)

        # calculate
        event.calculate_peak_and_ingress()
        event.calculate_ingress_matrix()
        event.calculate_delta_t_array()

        try:
            event.calculate_track()
        except Exception as e:
            print(e)
            pass


    def add_run(self, runpath):

        segment_number   = self.check_segment_number(runpath)
        self.event_num  += segment_number

        info_path        = os.path.join(runpath, "scope-1_info.txt")
        timestamps       = self.get_timestamps(info_path, segment_number)
        total_time       = timestamps[-1]
        self.total_time += total_time
        
        rate           = np.round(segment_number / total_time,3)
        self.rates.append(rate)

        for segment in range(1, segment_number+1):
            try:
                event = Event(runpath, segment)
                self.event_processor(event)

                timestamp = event.get_timestamp()
                angle     = event.get_angle()
                hits      = np.sum(event.get_hit_bools())

                if angle == None:
                    angle = np.nan
                if timestamp == None:
                    timestamp = np.nan

                tup       = (timestamp, angle, hits) #, hits)
                self.data.append(tup)

            except Exception as e:
                print(e)


    # == Get Methods == #

    def get_data(self):
        data = np.array(self.data)
        return data


    def get_rate(self):
        rate  = self.event_num / self.total_time
        drate = np.sqrt(self.event_num) / self.total_time 
        return rate, drate


# --------
# Testing
# --------

if __name__ == "__main__":

    import matplotlib.pyplot as plt
    from matplotlib.backends.backend_pdf import PdfPages

    # Add src directory to system path
    project_path = os.getcwd().split("/src")[0]
    sys.path.append(project_path)

    # Define path to pdf
    pdf_path      = os.path.join(out_path, "run.pdf")

    # Initialise pdf
    pdf           = PdfPages(pdf_path)

    #run_num = sys.argv[1]

    #runs = [0]
    #runs = [1,2]
    #runs = [1,2,3,4,5,6,7,8,9,10]
    runs = [11,12]
    #runs = [13,14,15,16]

    run = Run()
    for run_num in runs:
        run_path = os.path.join(lcd_path, f"Run{run_num}")
        run.add_run(run_path)

    data = run.get_data()

    angle_vals = np.array([tup[1] for tup in data if np.sum(tup[2])==2])
    angle_vals_3 = np.array([tup[1] for tup in data if np.sum(tup[2])==3])
    angle_vals_4 = np.array([tup[1] for tup in data if np.sum(tup[2])==4])
    timestamps = np.array([tup[0] for tup in data])

    # Remove NaN values
    valid_indices = ~np.isnan(angle_vals)
    valid_indices_3 = ~np.isnan(angle_vals_3)
    valid_indices_4 = ~np.isnan(angle_vals_4)

    angle_vals_clean = angle_vals[valid_indices]
    angle_vals_clean_3 = angle_vals_3[valid_indices_3]
    angle_vals_clean_4 = angle_vals_4[valid_indices_4]

    valid_indices = ~np.isnan(timestamps)
    timestamps_clean = timestamps[valid_indices]
    timestamps_diff = np.diff(np.array(timestamps_clean))

    bins = np.arange(0,60*10, 10)
    timestamps_x, diff_y = hist_to_scatter(timestamps_diff, bins = bins)

    fig, (ax1, ax2) = plt.subplots(nrows=2, ncols=1)
    bins = np.arange(-95,95,10)
    ax1.hist(angle_vals_clean, bins = bins, edgecolor='black')
    ax1.hist(angle_vals_clean_3, bins = bins, edgecolor='black')
    ax1.hist(angle_vals_clean_4, bins = bins, edgecolor='black')

    #bins = 16 #np.arange(0,30,1)
    ax2.scatter(timestamps_x, diff_y)


    pdf.savefig()

    # Close pdf
    pdf.close()

    print(run.rate)
